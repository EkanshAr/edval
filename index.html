<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eknash's Mini Golf</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #2c3e50;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            max-width: 900px;
            width: 100%;
            animation: slideIn 0.8s ease-out;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .top-ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .score-section {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 18px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-2px);
        }

        .coins-card {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
        }

        .controls-section {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .power-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .power-bar {
            width: 200px;
            height: 20px;
            background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 2px solid #34495e;
        }

        .power-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60 0%, #2ecc71 20%, #f1c40f 40%, #e67e22 70%, #e74c3c 100%);
            transition: width 0.1s ease-out;
            border-radius: 8px;
            width: 0%;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0px);
        }

        .btn.success {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .btn.shop {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.3);
        }

        .equipment-section {
            margin: 20px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
        }

        .equipment-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .club-selector,
        .ball-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .equipment-option {
            padding: 10px 15px;
            border: 2px solid #667eea;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .equipment-option.selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: scale(1.05);
        }

        .equipment-option.locked {
            background: #95a5a6;
            border-color: #95a5a6;
            color: #7f8c8d;
            cursor: not-allowed;
        }

        .equipment-option:hover:not(.locked) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        canvas {
            border: 4px solid #2c3e50;
            border-radius: 15px;
            background: #228B22;
            cursor: crosshair;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: block;
            margin: 20px auto;
            max-width: 100%;
        }

        .instructions {
            text-align: center;
            color: #5a6c7d;
            font-size: 15px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border-left: 4px solid #667eea;
        }

        /* Shop Modal */
        .shop-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .shop-content {
            background: white;
            border-radius: 25px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #ecf0f1;
        }

        .shop-title {
            font-size: 2em;
            font-weight: 700;
            color: #2c3e50;
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .close-btn {
            background: #e74c3c;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }

        .shop-section {
            margin-bottom: 30px;
        }

        .shop-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
            font-weight: 600;
        }

        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .shop-item {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .shop-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .shop-item.owned {
            border-color: #27ae60;
            background: linear-gradient(135deg, #d5f4e6, #a8e6cf);
        }

        .shop-item-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .shop-item-price {
            color: #f39c12;
            font-weight: 700;
            margin-bottom: 15px;
        }

        .buy-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .buy-btn:hover {
            transform: scale(1.05);
        }

        .buy-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        /* Level selection modal */
        .level-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .level-content {
            background: white;
            border-radius: 25px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
        }

        .level-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #ecf0f1;
        }

        .level-title {
            font-size: 2em;
            font-weight: 700;
            color: #2c3e50;
            background: linear-gradient(135deg, #3498db, #2980b9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .level-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            border: 3px solid transparent;
        }

        .level-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border-color: #3498db;
        }

        .level-card.locked {
            background: #95a5a6;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .level-card.current {
            border-color: #27ae60;
            background: linear-gradient(135deg, #d5f4e6, #a8e6cf);
        }

        .level-number {
            font-size: 2em;
            font-weight: 700;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .level-card.locked .level-number {
            color: #7f8c8d;
        }

        .level-difficulty {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        .difficulty-dot {
            width: 10px;
            height: 10px;
            background: #bdc3c7;
            border-radius: 50%;
            margin: 0 3px;
        }

        .difficulty-dot.active {
            background: #e74c3c;
        }

        /* Notification system */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 1100;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification-icon {
            font-size: 24px;
        }

        .notification-content {
            display: flex;
            flex-direction: column;
        }

        .notification-title {
            font-weight: 600;
            color: #2c3e50;
        }

        .notification-message {
            font-size: 14px;
            color: #7f8c8d;
        }

        /* Coin animation */
        @keyframes coinPop {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }

            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 1;
            }

            100% {
                transform: scale(1) translateY(-50px) rotate(360deg);
                opacity: 0;
            }
        }

        .coin-animation {
            position: absolute;
            font-size: 24px;
            animation: coinPop 1s forwards;
            z-index: 1000;
            pointer-events: none;
        }

        /* Level preview */
        .level-preview {
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .level-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .level-name {
            font-weight: 600;
            font-size: 18px;
            color: #2c3e50;
        }

        .level-description {
            font-size: 14px;
            color: #7f8c8d;
        }

        .level-buttons {
            display: flex;
            gap: 10px;
        }

        .mini-map {
            width: 100px;
            height: 75px;
            background: #228B22;
            border-radius: 8px;
            border: 2px solid #2c3e50;
            position: relative;
        }

        .mini-map-hole {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .mini-map-ball {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .mini-map-obstacle {
            position: absolute;
            background: #8B4513;
            transform: translate(-50%, -50%);
        }

        /* Decorative elements */
        .tree {
            position: absolute;
            width: 30px;
            height: 40px;
        }

        .tree-trunk {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 15px;
            background: #8B4513;
        }

        .tree-top {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 25px;
            height: 30px;
            background: #228B22;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        }

        .water {
            position: absolute;
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-radius: 50%;
            opacity: 0.8;
        }

        .sand {
            position: absolute;
            background: #f9ca24;
            border-radius: 50%;
            opacity: 0.8;
        }

        /* Animations */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .pulse {
            animation: pulse 1s infinite;
        }

        @keyframes celebrate {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2) rotate(5deg);
            }

            100% {
                transform: scale(1);
            }
        }

        .celebrate {
            animation: celebrate 0.5s;
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
            }

            .top-ui {
                flex-direction: column;
            }

            canvas {
                width: 100%;
                height: auto;
            }

            .equipment-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .controls-section {
                flex-direction: column;
                align-items: stretch;
            }

            .power-container {
                width: 100%;
            }

            .power-bar {
                flex-grow: 1;
            }
        }
    </style>
    <script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
</head>

<body>
    <div class="game-container">
        <h1>üèåÔ∏è Mini Golf Championship</h1>

        <div class="level-preview">
            <div class="level-info">
                <div class="level-name">Level <span id="levelNameDisplay">1</span>: <span id="levelTitle">Beginner's
                        Green</span></div>
                <div class="level-description" id="levelDescription">A simple course to get you started. Perfect your
                    aim!</div>
            </div>
            <div class="mini-map" id="miniMap">
                <!-- Mini-map elements will be added dynamically -->
            </div>
            <div class="level-buttons">
                <button class="btn" id="levelSelectBtn">Levels</button>
            </div>
        </div>

        <div class="top-ui">
            <div class="score-section">
                <div class="stat-card">Level: <span id="currentLevel">1</span></div>
                <div class="stat-card">Strokes: <span id="strokes">0</span></div>
                <div class="stat-card">Par: <span id="parDisplay">3</span></div>
                <div class="stat-card">Best: <span id="bestScore">--</span></div>
                <div class="stat-card coins-card">üí∞ <span id="coins">0</span> Coins</div>
            </div>

            <div class="controls-section">
                <div class="power-container">
                    <span>Power:</span>
                    <div class="power-bar">
                        <div class="power-fill" id="powerFill"></div>
                    </div>
                </div>
                <button class="btn" id="resetBtn">Reset</button>
                <button class="btn success" id="nextBtn">Next Level</button>
                <button class="btn shop" id="shopBtn">üõí Shop</button>
            </div>
        </div>

        <div class="equipment-section">
            <div class="equipment-row">
                <div>
                    <strong>Club:</strong>
                    <div class="club-selector">
                        <div class="equipment-option selected" data-club="putter" id="club-putter">üèåÔ∏è Putter</div>
                        <div class="equipment-option locked" data-club="iron" id="club-iron">‚õ≥ Iron (5üí∞)</div>
                        <div class="equipment-option locked" data-club="driver" id="club-driver">üèåÔ∏è‚Äç‚ôÇÔ∏è Driver (15üí∞)
                        </div>
                        <div class="equipment-option locked" data-club="wedge" id="club-wedge">üèåÔ∏è‚Äç‚ôÄÔ∏è Wedge (20üí∞)</div>
                    </div>
                </div>
            </div>

            <div class="equipment-row">
                <div>
                    <strong>Ball:</strong>
                    <div class="ball-selector">
                        <div class="equipment-option selected" data-ball="classic" id="ball-classic">‚ö™ Classic</div>
                        <div class="equipment-option locked" data-ball="gold" id="ball-gold">üü° Gold (10üí∞)</div>
                        <div class="equipment-option locked" data-ball="rainbow" id="ball-rainbow">üåà Rainbow (20üí∞)
                        </div>
                        <div class="equipment-option locked" data-ball="fire" id="ball-fire">üî• Fire (30üí∞)</div>
                        <div class="equipment-option locked" data-ball="crystal" id="ball-crystal">üíé Crystal (40üí∞)
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="instructions">
            <strong>How to Play:</strong> Click and drag from the ball to aim and set power. Release to shoot!<br>
            <strong>Scoring:</strong> Hole in 1 = 5üí∞ | Hole in 2 = 3üí∞ | Hole in 3 = 1üí∞<br>
            <strong>Clubs:</strong> Putter (precise, low power) | Iron (balanced) | Driver (powerful, less precise) |
            Wedge (high loft, good for obstacles)
        </div>
    </div>

    <!-- Shop Modal -->
    <div class="shop-modal" id="shopModal">
        <div class="shop-content">
            <div class="shop-header">
                <h2 class="shop-title">üõí Pro Shop</h2>
                <button class="close-btn" id="closeShopBtn">√ó</button>
            </div>

            <div class="shop-section">
                <h3>üèåÔ∏è Golf Clubs</h3>
                <div class="shop-items">
                    <div class="shop-item owned">
                        <div class="shop-item-name">üèåÔ∏è Putter</div>
                        <div class="shop-item-price">FREE</div>
                        <button class="buy-btn" disabled>Owned</button>
                    </div>
                    <div class="shop-item" id="iron-shop">
                        <div class="shop-item-name">‚õ≥ Iron Club</div>
                        <div class="shop-item-price">5üí∞</div>
                        <button class="buy-btn" data-item="iron" data-price="5">Buy</button>
                    </div>
                    <div class="shop-item" id="driver-shop">
                        <div class="shop-item-name">üèåÔ∏è‚Äç‚ôÇÔ∏è Driver</div>
                        <div class="shop-item-price">15üí∞</div>
                        <button class="buy-btn" data-item="driver" data-price="15">Buy</button>
                    </div>
                    <div class="shop-item" id="wedge-shop">
                        <div class="shop-item-name">üèåÔ∏è‚Äç‚ôÄÔ∏è Wedge</div>
                        <div class="shop-item-price">20üí∞</div>
                        <button class="buy-btn" data-item="wedge" data-price="20">Buy</button>
                    </div>
                </div>
            </div>

            <div class="shop-section">
                <h3>‚öΩ Golf Balls</h3>
                <div class="shop-items">
                    <div class="shop-item owned">
                        <div class="shop-item-name">‚ö™ Classic Ball</div>
                        <div class="shop-item-price">FREE</div>
                        <button class="buy-btn" disabled>Owned</button>
                    </div>
                    <div class="shop-item" id="gold-shop">
                        <div class="shop-item-name">üü° Gold Ball</div>
                        <div class="shop-item-price">10üí∞</div>
                        <button class="buy-btn" data-item="gold" data-price="10">Buy</button>
                    </div>
                    <div class="shop-item" id="rainbow-shop">
                        <div class="shop-item-name">üåà Rainbow Ball</div>
                        <div class="shop-item-price">20üí∞</div>
                        <button class="buy-btn" data-item="rainbow" data-price="20">Buy</button>
                    </div>
                    <div class="shop-item" id="fire-shop">
                        <div class="shop-item-name">üî• Fire Ball</div>
                        <div class="shop-item-price">30üí∞</div>
                        <button class="buy-btn" data-item="fire" data-price="30">Buy</button>
                    </div>
                    <div class="shop-item" id="crystal-shop">
                        <div class="shop-item-name">üíé Crystal Ball</div>
                        <div class="shop-item-price">40üí∞</div>
                        <button class="buy-btn" data-item="crystal" data-price="40">Buy</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Level Selection Modal -->
    <div class="level-modal" id="levelModal">
        <div class="level-content">
            <div class="level-header">
                <h2 class="level-title">üèÜ Select Level</h2>
                <button class="close-btn" id="closeLevelBtn">√ó</button>
            </div>

            <div class="level-grid" id="levelGrid">
                <!-- Level cards will be added dynamically -->
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">
        <div class="notification-icon">üéâ</div>
        <div class="notification-content">
            <div class="notification-title">Great Shot!</div>
            <div class="notification-message">You earned 3 coins!</div>
        </div>
    </div>

    <script>
        // Game elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI elements
        const strokesElement = document.getElementById('strokes');
        const bestScoreElement = document.getElementById('bestScore');
        const powerFillElement = document.getElementById('powerFill');
        const currentLevelElement = document.getElementById('currentLevel');
        const coinsElement = document.getElementById('coins');
        const parDisplay = document.getElementById('parDisplay');
        const levelNameDisplay = document.getElementById('levelNameDisplay');
        const levelTitle = document.getElementById('levelTitle');
        const levelDescription = document.getElementById('levelDescription');
        const miniMap = document.getElementById('miniMap');
        const notification = document.getElementById('notification');
        const levelGrid = document.getElementById('levelGrid');

        // Game state
        let gameState = {
            ball: { x: 100, y: 500, vx: 0, vy: 0, radius: 8 },
            hole: { x: 700, y: 100, radius: 20 },
            strokes: 0,
            bestScores: JSON.parse(localStorage.getItem('golfBestScores')) || {},
            isAiming: false,
            aimStart: { x: 0, y: 0 },
            aimEnd: { x: 0, y: 0 },
            gameWon: false,
            currentLevel: 1,
            maxUnlockedLevel: parseInt(localStorage.getItem('golfMaxLevel')) || 1,
            selectedClub: 'putter',
            selectedBall: 'classic',
            coins: parseInt(localStorage.getItem('golfCoins')) || 0,
            ownedItems: JSON.parse(localStorage.getItem('golfOwnedItems')) || ['putter', 'classic'],
            obstacles: [],
            decorations: [],
            ballMoving: false,
            ballInHole: false,
            showTrajectory: true
        };

        // Club configurations
        const clubs = {
            putter: { maxPower: 25, precision: 1.0, name: 'Putter', price: 0, description: 'Precise but low power' },
            iron: { maxPower: 40, precision: 0.8, name: 'Iron', price: 5, description: 'Balanced power and precision' },
            driver: { maxPower: 60, precision: 0.6, name: 'Driver', price: 15, description: 'High power, less precise' },
            wedge: { maxPower: 35, precision: 0.9, name: 'Wedge', price: 20, description: 'Good for obstacles and sand' }
        };

        // Ball configurations
        const balls = {
            classic: { name: 'Classic', price: 0, color: 'white', effect: null, description: 'Standard golf ball' },
            gold: { name: 'Gold', price: 10, color: '#FFD700', effect: 'shine', description: '+10% coins' },
            rainbow: { name: 'Rainbow', price: 20, color: 'rainbow', effect: 'rainbow', description: 'Less affected by obstacles' },
            fire: { name: 'Fire', price: 30, color: '#FF4500', effect: 'fire', description: 'Moves faster on grass' },
            crystal: { name: 'Crystal', price: 40, color: '#88CCFF', effect: 'crystal', description: 'Better precision' }
        };

        // Level configurations
        const levels = [
            {
                name: "Beginner's Green",
                description: "A simple course to get you started. Perfect your aim!",
                par: 3,
                ball: { x: 100, y: 500 },
                hole: { x: 700, y: 100 },
                obstacles: [
                    { type: 'log', x: 300, y: 300, width: 100, height: 20, rotation: 0 },
                    { type: 'stone', x: 500, y: 200, radius: 25 }
                ],
                decorations: [
                    { type: 'tree', x: 50, y: 50 },
                    { type: 'tree', x: 750, y: 550 },
                    { type: 'tree', x: 750, y: 50 }
                ]
            },
            {
                name: "Sandy Challenge",
                description: "Watch out for the sand traps! They'll slow you down.",
                par: 4,
                ball: { x: 50, y: 550 },
                hole: { x: 750, y: 50 },
                obstacles: [
                    { type: 'wall', x: 200, y: 200, width: 20, height: 200, rotation: 0 },
                    { type: 'boulder', x: 400, y: 300, radius: 30 },
                    { type: 'log', x: 500, y: 450, width: 150, height: 20, rotation: 0 },
                    { type: 'stone', x: 600, y: 150, radius: 20 },
                    { type: 'sand', x: 300, y: 400, width: 120, height: 80 }
                ],
                decorations: [
                    { type: 'tree', x: 100, y: 100 },
                    { type: 'tree', x: 700, y: 500 },
                    { type: 'tree', x: 200, y: 500 }
                ]
            },
            {
                name: "Water Hazard",
                description: "Avoid the water or your ball will be penalized!",
                par: 4,
                ball: { x: 400, y: 550 },
                hole: { x: 400, y: 50 },
                obstacles: [
                    { type: 'wall', x: 100, y: 100, width: 20, height: 150, rotation: 0 },
                    { type: 'wall', x: 680, y: 100, width: 20, height: 150, rotation: 0 },
                    { type: 'log', x: 200, y: 300, width: 120, height: 20, rotation: 0 },
                    { type: 'log', x: 480, y: 300, width: 120, height: 20, rotation: 0 },
                    { type: 'boulder', x: 400, y: 350, radius: 25 },
                    { type: 'water', x: 400, y: 250, width: 200, height: 80 }
                ],
                decorations: [
                    { type: 'tree', x: 50, y: 200 },
                    { type: 'tree', x: 750, y: 200 },
                    { type: 'tree', x: 400, y: 150 }
                ]
            },
            {
                name: "Forest Path",
                description: "Navigate through the trees to find the hole.",
                par: 5,
                ball: { x: 100, y: 300 },
                hole: { x: 700, y: 300 },
                obstacles: [
                    { type: 'log', x: 200, y: 200, width: 20, height: 400, rotation: 0 },
                    { type: 'log', x: 400, y: 0, width: 20, height: 200, rotation: 0 },
                    { type: 'log', x: 400, y: 400, width: 20, height: 200, rotation: 0 },
                    { type: 'log', x: 600, y: 200, width: 20, height: 400, rotation: 0 },
                    { type: 'boulder', x: 300, y: 150, radius: 20 },
                    { type: 'boulder', x: 300, y: 450, radius: 20 },
                    { type: 'boulder', x: 500, y: 150, radius: 20 },
                    { type: 'boulder', x: 500, y: 450, radius: 20 }
                ],
                decorations: [
                    { type: 'tree', x: 150, y: 100 },
                    { type: 'tree', x: 150, y: 500 },
                    { type: 'tree', x: 650, y: 100 },
                    { type: 'tree', x: 650, y: 500 },
                    { type: 'tree', x: 300, y: 300 },
                    { type: 'tree', x: 500, y: 300 }
                ]
            },
            {
                name: "Zigzag Valley",
                description: "You'll need strategy to navigate this winding course.",
                par: 5,
                ball: { x: 50, y: 550 },
                hole: { x: 750, y: 50 },
                obstacles: [
                    { type: 'wall', x: 150, y: 100, width: 500, height: 20, rotation: 0 },
                    { type: 'wall', x: 150, y: 250, width: 500, height: 20, rotation: 0 },
                    { type: 'wall', x: 150, y: 400, width: 500, height: 20, rotation: 0 },
                    { type: 'wall', x: 150, y: 100, width: 20, height: 170, rotation: 0 },
                    { type: 'wall', x: 650, y: 250, width: 20, height: 170, rotation: 0 },
                    { type: 'sand', x: 400, y: 175, width: 100, height: 50 },
                    { type: 'sand', x: 400, y: 325, width: 100, height: 50 },
                    { type: 'water', x: 400, y: 475, width: 150, height: 50 }
                ],
                decorations: [
                    { type: 'tree', x: 100, y: 50 },
                    { type: 'tree', x: 700, y: 200 },
                    { type: 'tree', x: 100, y: 350 },
                    { type: 'tree', x: 700, y: 500 }
                ]
            },
            {
                name: "The Gauntlet",
                description: "The ultimate challenge! Can you make it through?",
                par: 6,
                ball: { x: 400, y: 550 },
                hole: { x: 400, y: 50 },
                obstacles: [
                    // Center channel
                    { type: 'wall', x: 300, y: 100, width: 20, height: 400, rotation: 0 },
                    { type: 'wall', x: 480, y: 100, width: 20, height: 400, rotation: 0 },

                    // Rotating barriers
                    { type: 'log', x: 350, y: 150, width: 80, height: 15, rotation: 45 },
                    { type: 'log', x: 350, y: 250, width: 80, height: 15, rotation: -45 },
                    { type: 'log', x: 350, y: 350, width: 80, height: 15, rotation: 45 },
                    { type: 'log', x: 350, y: 450, width: 80, height: 15, rotation: -45 },

                    // Side hazards
                    { type: 'water', x: 150, y: 200, width: 100, height: 80 },
                    { type: 'water', x: 650, y: 200, width: 100, height: 80 },
                    { type: 'sand', x: 150, y: 400, width: 100, height: 80 },
                    { type: 'sand', x: 650, y: 400, width: 100, height: 80 },

                    // Boulders
                    { type: 'boulder', x: 200, y: 300, radius: 25 },
                    { type: 'boulder', x: 600, y: 300, radius: 25 },
                    { type: 'boulder', x: 400, y: 500, radius: 20 },
                    { type: 'boulder', x: 400, y: 100, radius: 20 }
                ],
                decorations: [
                    { type: 'tree', x: 100, y: 100 },
                    { type: 'tree', x: 700, y: 100 },
                    { type: 'tree', x: 100, y: 500 },
                    { type: 'tree', x: 700, y: 500 },
                    { type: 'tree', x: 200, y: 50 },
                    { type: 'tree', x: 600, y: 50 },
                    { type: 'tree', x: 200, y: 550 },
                    { type: 'tree', x: 600, y: 550 }
                ]
            }
        ];

        const FRICTION = 0.98;
        const MIN_VELOCITY = 0.1;
        const WATER_PENALTY = 2;
        const SAND_FRICTION = 0.8;

        // Save/Load functions
        function saveGameData() {
            localStorage.setItem('golfCoins', gameState.coins);
            localStorage.setItem('golfOwnedItems', JSON.stringify(gameState.ownedItems));
            localStorage.setItem('golfBestScores', JSON.stringify(gameState.bestScores));
            localStorage.setItem('golfMaxLevel', gameState.maxUnlockedLevel);
        }

        function updateCoinsDisplay() {
            coinsElement.textContent = gameState.coins;
        }

        function awardCoins(strokes) {
            let coinsEarned = 0;
            const level = levels[gameState.currentLevel - 1];
            const par = level.par;

            // Award coins based on performance relative to par
            if (strokes === 1) {
                // Hole in one - special bonus!
                coinsEarned = 5;
                showNotification('üéØ Hole in One!', `Amazing shot! +${coinsEarned} coins`);
            } else if (strokes <= par - 2) {
                // Eagle or better
                coinsEarned = 4;
                showNotification('ü¶Ö Eagle!', `Excellent! +${coinsEarned} coins`);
            } else if (strokes === par - 1) {
                // Birdie
                coinsEarned = 3;
                showNotification('üê¶ Birdie!', `Great shot! +${coinsEarned} coins`);
            } else if (strokes === par) {
                // Par
                coinsEarned = 2;
                showNotification('üëç Par!', `Good job! +${coinsEarned} coins`);
            } else if (strokes === par + 1) {
                // Bogey
                coinsEarned = 1;
                showNotification('üòê Bogey', `Not bad! +${coinsEarned} coins`);
            }

            // Gold ball bonus
            if (gameState.selectedBall === 'gold' && coinsEarned > 0) {
                const bonus = Math.ceil(coinsEarned * 0.1);
                coinsEarned += bonus;
                setTimeout(() => {
                    showNotification('‚ú® Gold Ball Bonus', `+${bonus} extra coins!`);
                }, 2000);
            }

            if (coinsEarned > 0) {
                gameState.coins += coinsEarned;
                saveGameData();
                updateCoinsDisplay();

                // Create coin animation
                createCoinAnimation(gameState.hole.x, gameState.hole.y, coinsEarned);

                return coinsEarned;
            }
            return 0;
        }

        function createCoinAnimation(x, y, count) {
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'coin-animation';
                    coin.textContent = 'üí∞';
                    coin.style.left = `${x}px`;
                    coin.style.top = `${y}px`;
                    document.body.appendChild(coin);

                    setTimeout(() => {
                        coin.remove();
                    }, 1000);
                }, i * 200);
            }
        }

        function showNotification(title, message) {
            const notificationTitle = notification.querySelector('.notification-title');
            const notificationMessage = notification.querySelector('.notification-message');

            notificationTitle.textContent = title;
            notificationMessage.textContent = message;

            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Equipment functions
        function selectClub(clubType) {
            if (!gameState.ownedItems.includes(clubType)) {
                showNotification('‚ùå Not Owned', `You need to purchase the ${clubs[clubType].name} first!`);
                return;
            }

            gameState.selectedClub = clubType;
            document.querySelectorAll('.equipment-option[data-club]').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`[data-club="${clubType}"]`).classList.add('selected');

            showNotification('üèåÔ∏è Club Selected', `${clubs[clubType].name}: ${clubs[clubType].description}`);
        }

        function selectBall(ballType) {
            if (!gameState.ownedItems.includes(ballType)) {
                showNotification('‚ùå Not Owned', `You need to purchase the ${balls[ballType].name} ball first!`);
                return;
            }

            gameState.selectedBall = ballType;
            document.querySelectorAll('.equipment-option[data-ball]').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`[data-ball="${ballType}"]`).classList.add('selected');

            showNotification('‚ö™ Ball Selected', `${balls[ballType].name}: ${balls[ballType].description}`);
        }

        // Shop functions
        function openShop() {
            document.getElementById('shopModal').style.display = 'flex';
            updateShopDisplay();
        }

        function closeShop() {
            document.getElementById('shopModal').style.display = 'none';
        }

        function updateShopDisplay() {
            // Update shop items based on owned items
            gameState.ownedItems.forEach(item => {
                const shopItem = document.getElementById(`${item}-shop`);
                if (shopItem) {
                    shopItem.classList.add('owned');
                    const buyBtn = shopItem.querySelector('.buy-btn');
                    buyBtn.textContent = 'Owned';
                    buyBtn.disabled = true;
                }
            });
        }

        function buyItem(itemType, price) {
            if (gameState.coins >= price && !gameState.ownedItems.includes(itemType)) {
                gameState.coins -= price;
                gameState.ownedItems.push(itemType);
                saveGameData();
                updateCoinsDisplay();
                updateShopDisplay();
                updateEquipmentDisplay();

                // Determine if it's a club or ball
                let itemCategory = '';
                if (Object.keys(clubs).includes(itemType)) {
                    itemCategory = 'Club';
                } else if (Object.keys(balls).includes(itemType)) {
                    itemCategory = 'Ball';
                }

                showNotification('üõçÔ∏è Purchase Complete', `${itemType} ${itemCategory} is now yours!`);
            } else if (gameState.coins < price) {
                showNotification('‚ùå Not Enough Coins', 'Keep playing to earn more coins!');
            } else {
                showNotification('‚ÑπÔ∏è Already Owned', 'You already own this item!');
            }
        }

        function updateEquipmentDisplay() {
            // Update equipment display based on owned items
            gameState.ownedItems.forEach(item => {
                const equipmentOption = document.querySelector(`[data-club="${item}"], [data-ball="${item}"]`);
                if (equipmentOption) {
                    equipmentOption.classList.remove('locked');
                }
            });
        }

        // Level functions
        function loadLevel(levelIndex) {
            if (levelIndex >= levels.length) {
                showNotification('üèÜ Congratulations!', 'You completed all levels!');
                return;
            }

            const level = levels[levelIndex];

            // Reset game state
            gameState.ball.x = level.ball.x;
            gameState.ball.y = level.ball.y;
            gameState.ball.vx = 0;
            gameState.ball.vy = 0;
            gameState.hole.x = level.hole.x;
            gameState.hole.y = level.hole.y;
            gameState.obstacles = JSON.parse(JSON.stringify(level.obstacles)); // Deep copy
            gameState.decorations = JSON.parse(JSON.stringify(level.decorations)); // Deep copy
            gameState.strokes = 0;
            gameState.gameWon = false;
            gameState.ballInHole = false;
            gameState.ballMoving = false;

            // Update UI
            updateDisplay();
            updateLevelInfo();
            updateMiniMap();

            // Show level notification
            showNotification(`üèåÔ∏è Level ${gameState.currentLevel}: ${level.name}`, level.description);
        }

        function updateLevelInfo() {
            const level = levels[gameState.currentLevel - 1];
            levelNameDisplay.textContent = gameState.currentLevel;
            levelTitle.textContent = level.name;
            levelDescription.textContent = level.description;
            parDisplay.textContent = level.par;
        }

        function updateMiniMap() {
            // Clear mini-map
            miniMap.innerHTML = '';

            const level = levels[gameState.currentLevel - 1];
            const mapWidth = miniMap.offsetWidth;
            const mapHeight = miniMap.offsetHeight;

            // Scale factors
            const scaleX = mapWidth / canvas.width;
            const scaleY = mapHeight / canvas.height;

            // Add hole
            const holeElement = document.createElement('div');
            holeElement.className = 'mini-map-hole';
            holeElement.style.left = `${level.hole.x * scaleX}px`;
            holeElement.style.top = `${level.hole.y * scaleY}px`;
            miniMap.appendChild(holeElement);

            // Add ball
            const ballElement = document.createElement('div');
            ballElement.className = 'mini-map-ball';
            ballElement.style.left = `${level.ball.x * scaleX}px`;
            ballElement.style.top = `${level.ball.y * scaleY}px`;
            miniMap.appendChild(ballElement);

            // Add obstacles (simplified)
            level.obstacles.forEach(obstacle => {
                if (obstacle.type === 'wall' || obstacle.type === 'log') {
                    const obstacleElement = document.createElement('div');
                    obstacleElement.className = 'mini-map-obstacle';
                    obstacleElement.style.left = `${(obstacle.x + obstacle.width / 2) * scaleX}px`;
                    obstacleElement.style.top = `${(obstacle.y + obstacle.height / 2) * scaleY}px`;
                    obstacleElement.style.width = `${obstacle.width * scaleX}px`;
                    obstacleElement.style.height = `${obstacle.height * scaleY}px`;

                    if (obstacle.type === 'water') {
                        obstacleElement.style.background = '#3498db';
                    } else if (obstacle.type === 'sand') {
                        obstacleElement.style.background = '#f9ca24';
                    }

                    miniMap.appendChild(obstacleElement);
                }
            });
        }

        function populateLevelGrid() {
            levelGrid.innerHTML = '';

            levels.forEach((level, index) => {
                const levelNumber = index + 1;
                const isUnlocked = levelNumber <= gameState.maxUnlockedLevel;
                const isCurrent = levelNumber === gameState.currentLevel;

                const levelCard = document.createElement('div');
                levelCard.className = `level-card${isUnlocked ? '' : ' locked'}${isCurrent ? ' current' : ''}`;

                const levelNumberElement = document.createElement('div');
                levelNumberElement.className = 'level-number';
                levelNumberElement.textContent = levelNumber;

                const levelNameElement = document.createElement('div');
                levelNameElement.textContent = level.name;

                const difficultyElement = document.createElement('div');
                difficultyElement.className = 'level-difficulty';

                // Add difficulty dots
                for (let i = 0; i < 5; i++) {
                    const dot = document.createElement('div');
                    dot.className = `difficulty-dot${i < level.par - 2 ? ' active' : ''}`;
                    difficultyElement.appendChild(dot);
                }

                levelCard.appendChild(levelNumberElement);
                levelCard.appendChild(levelNameElement);
                levelCard.appendChild(difficultyElement);

                if (isUnlocked) {
                    levelCard.addEventListener('click', () => {
                        selectLevel(levelNumber);
                    });
                }

                levelGrid.appendChild(levelCard);
            });
        }

        function selectLevel(levelNumber) {
            if (levelNumber <= gameState.maxUnlockedLevel) {
                gameState.currentLevel = levelNumber;
                loadLevel(levelNumber - 1);
                closeLevelModal();
            }
        }

        function openLevelModal() {
            populateLevelGrid();
            document.getElementById('levelModal').style.display = 'flex';
        }

        function closeLevelModal() {
            document.getElementById('levelModal').style.display = 'none';
        }

        // Drawing functions
        function drawGrassBackground() {
            // Base grass color
            const grassGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            grassGradient.addColorStop(0, '#32CD32');
            grassGradient.addColorStop(1, '#228B22');
            ctx.fillStyle = grassGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grass texture pattern
            ctx.fillStyle = 'rgba(34, 139, 34, 0.3)';
            for (let x = 0; x < canvas.width; x += 40) {
                for (let y = 0; y < canvas.height; y += 40) {
                    if ((x + y) % 80 === 0) {
                        ctx.fillRect(x, y, 20, 20);
                    }
                }
            }

            // Add some grass blades
            ctx.strokeStyle = 'rgba(0, 100, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.random() * 4 - 2, y - Math.random() * 8);
                ctx.stroke();
            }
        }

        function drawObstacle(obstacle) {
            ctx.save();

            switch (obstacle.type) {
                case 'log':
                    // Apply rotation if specified
                    if (obstacle.rotation) {
                        ctx.translate(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                        ctx.rotate(obstacle.rotation * Math.PI / 180);
                        ctx.translate(-(obstacle.x + obstacle.width / 2), -(obstacle.y + obstacle.height / 2));
                    }

                    // Draw wooden log with texture
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                    // Wood texture
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(obstacle.x + 2, obstacle.y + 2, obstacle.width - 4, obstacle.height - 4);

                    // Wood grain lines
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < obstacle.width; i += 8) {
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + i, obstacle.y);
                        ctx.lineTo(obstacle.x + i, obstacle.y + obstacle.height);
                        ctx.stroke();
                    }

                    // Log ends
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(obstacle.x, obstacle.y + obstacle.height / 2, obstacle.height / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(obstacle.x + obstacle.width, obstacle.y + obstacle.height / 2, obstacle.height / 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'stone':
                    // Draw stone with shading
                    ctx.fillStyle = '#708090';
                    ctx.beginPath();
                    ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Stone highlight
                    ctx.fillStyle = '#778899';
                    ctx.beginPath();
                    ctx.arc(obstacle.x - 3, obstacle.y - 3, obstacle.radius - 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Stone cracks
                    ctx.strokeStyle = '#2F4F4F';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x - obstacle.radius / 2, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.radius / 2, obstacle.y + obstacle.radius / 3);
                    ctx.stroke();
                    break;

                case 'wall':
                    // Apply rotation if specified
                    if (obstacle.rotation) {
                        ctx.translate(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                        ctx.rotate(obstacle.rotation * Math.PI / 180);
                        ctx.translate(-(obstacle.x + obstacle.width / 2), -(obstacle.y + obstacle.height / 2));
                    }

                    // Draw stone wall with blocks
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

                    // Wall highlight
                    ctx.fillStyle = '#808080';
                    ctx.fillRect(obstacle.x + 2, obstacle.y + 2, obstacle.width - 4, obstacle.height - 4);

                    // Stone blocks pattern
                    ctx.strokeStyle = '#2F4F4F';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < obstacle.height; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + i);
                        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + i);
                        ctx.stroke();
                    }

                    // Vertical lines for brick effect
                    for (let i = 0; i < obstacle.width; i += 30) {
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + i, obstacle.y);
                        ctx.lineTo(obstacle.x + i, obstacle.y + obstacle.height);
                        ctx.stroke();
                    }
                    break;

                case 'boulder':
                    // Draw large boulder with moss
                    ctx.fillStyle = '#556B2F';
                    ctx.beginPath();
                    ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Boulder highlight
                    ctx.fillStyle = '#6B8E23';
                    ctx.beginPath();
                    ctx.arc(obstacle.x - 5, obstacle.y - 5, obstacle.radius - 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Moss spots
                    ctx.fillStyle = '#228B22';
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const mossX = obstacle.x + Math.cos(angle) * (obstacle.radius * 0.6);
                        const mossY = obstacle.y + Math.sin(angle) * (obstacle.radius * 0.6);
                        ctx.beginPath();
                        ctx.arc(mossX, mossY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Boulder cracks
                    ctx.strokeStyle = '#2F4F4F';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x - obstacle.radius / 2, obstacle.y - obstacle.radius / 3);
                    ctx.lineTo(obstacle.x + obstacle.radius / 3, obstacle.y + obstacle.radius / 2);
                    ctx.stroke();
                    break;

                case 'water':
                    // Draw water hazard
                    ctx.fillStyle = 'rgba(52, 152, 219, 0.7)';
                    ctx.beginPath();
                    if (obstacle.radius) {
                        // Circular water hazard
                        ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                    } else {
                        // Rectangular water hazard
                        ctx.rect(obstacle.x - obstacle.width / 2, obstacle.y - obstacle.height / 2, obstacle.width, obstacle.height);
                    }
                    ctx.fill();

                    // Water ripple effect
                    ctx.strokeStyle = 'rgba(41, 128, 185, 0.5)';
                    ctx.lineWidth = 2;

                    if (obstacle.radius) {
                        for (let r = obstacle.radius * 0.3; r < obstacle.radius; r += obstacle.radius * 0.2) {
                            ctx.beginPath();
                            ctx.arc(obstacle.x, obstacle.y, r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    } else {
                        const centerX = obstacle.x;
                        const centerY = obstacle.y;
                        const maxRadius = Math.min(obstacle.width, obstacle.height) * 0.4;

                        for (let r = maxRadius * 0.3; r < maxRadius; r += maxRadius * 0.2) {
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                    break;

                case 'sand':
                    // Draw sand trap
                    ctx.fillStyle = '#f9ca24';
                    ctx.beginPath();
                    if (obstacle.radius) {
                        // Circular sand trap
                        ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                    } else {
                        // Rectangular sand trap
                        ctx.rect(obstacle.x - obstacle.width / 2, obstacle.y - obstacle.height / 2, obstacle.width, obstacle.height);
                    }
                    ctx.fill();

                    // Sand texture
                    ctx.fillStyle = '#f6e58d';
                    for (let i = 0; i < 30; i++) {
                        let dotX, dotY;

                        if (obstacle.radius) {
                            // For circular sand traps
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * obstacle.radius * 0.9;
                            dotX = obstacle.x + Math.cos(angle) * distance;
                            dotY = obstacle.y + Math.sin(angle) * distance;
                        } else {
                            // For rectangular sand traps
                            dotX = (obstacle.x - obstacle.width / 2) + Math.random() * obstacle.width;
                            dotY = (obstacle.y - obstacle.height / 2) + Math.random() * obstacle.height;
                        }

                        ctx.beginPath();
                        ctx.arc(dotX, dotY, 1 + Math.random() * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
            }

            ctx.restore();
        }

        function drawDecoration(decoration) {
            ctx.save();

            switch (decoration.type) {
                case 'tree':
                    // Draw tree trunk
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(decoration.x - 3, decoration.y - 15, 6, 15);

                    // Draw tree foliage
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(decoration.x, decoration.y - 25, 15, 0, Math.PI * 2);
                    ctx.fill();

                    // Add some texture to the foliage
                    ctx.fillStyle = '#32CD32';
                    ctx.beginPath();
                    ctx.arc(decoration.x + 5, decoration.y - 30, 8, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'flower':
                    // Draw flower stem
                    ctx.strokeStyle = '#228B22';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(decoration.x, decoration.y);
                    ctx.lineTo(decoration.x, decoration.y - 10);
                    ctx.stroke();

                    // Draw flower petals
                    const colors = ['#FF6B6B', '#FFCC5C', '#88D8B0', '#FF6B6B'];
                    const petalSize = 4;

                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.fillStyle = colors[i % colors.length];
                        ctx.beginPath();
                        ctx.arc(
                            decoration.x + Math.cos(angle) * petalSize,
                            (decoration.y - 10) + Math.sin(angle) * petalSize,
                            petalSize,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }

                    // Draw flower center
                    ctx.fillStyle = '#FFCC5C';
                    ctx.beginPath();
                    ctx.arc(decoration.x, decoration.y - 10, petalSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
            }

            ctx.restore();
        }

        function drawBall() {
            if (gameState.ballInHole) return; // Don't draw if ball is in hole

            ctx.save();

            // Draw ball shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(gameState.ball.x + 3, gameState.ball.y + 3, gameState.ball.radius + 1, gameState.ball.radius * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Draw ball based on type
            switch (gameState.selectedBall) {
                case 'classic':
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 2;
                    break;

                case 'gold':
                    const goldGradient = ctx.createRadialGradient(
                        gameState.ball.x - 3, gameState.ball.y - 3, 0,
                        gameState.ball.x, gameState.ball.y, gameState.ball.radius
                    );
                    goldGradient.addColorStop(0, '#FFFF99');
                    goldGradient.addColorStop(1, '#FFD700');
                    ctx.fillStyle = goldGradient;
                    ctx.strokeStyle = '#FFA500';
                    ctx.lineWidth = 2;
                    break;

                case 'rainbow':
                    const rainbowGradient = ctx.createRadialGradient(
                        gameState.ball.x - 3, gameState.ball.y - 3, 0,
                        gameState.ball.x, gameState.ball.y, gameState.ball.radius
                    );
                    rainbowGradient.addColorStop(0, '#ff0000');
                    rainbowGradient.addColorStop(0.16, '#ff8000');
                    rainbowGradient.addColorStop(0.33, '#ffff00');
                    rainbowGradient.addColorStop(0.5, '#00ff00');
                    rainbowGradient.addColorStop(0.66, '#0080ff');
                    rainbowGradient.addColorStop(0.83, '#8000ff');
                    rainbowGradient.addColorStop(1, '#ff0080');
                    ctx.fillStyle = rainbowGradient;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    break;

                case 'fire':
                    const fireGradient = ctx.createRadialGradient(
                        gameState.ball.x - 2, gameState.ball.y - 2, 0,
                        gameState.ball.x, gameState.ball.y, gameState.ball.radius
                    );
                    fireGradient.addColorStop(0, '#FFFF00');
                    fireGradient.addColorStop(0.3, '#FF8C00');
                    fireGradient.addColorStop(0.7, '#FF4500');
                    fireGradient.addColorStop(1, '#8B0000');
                    ctx.fillStyle = fireGradient;
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 2;
                    break;

                case 'crystal':
                    const crystalGradient = ctx.createRadialGradient(
                        gameState.ball.x - 3, gameState.ball.y - 3, 0,
                        gameState.ball.x, gameState.ball.y, gameState.ball.radius
                    );
                    crystalGradient.addColorStop(0, '#FFFFFF');
                    crystalGradient.addColorStop(0.3, '#AADDFF');
                    crystalGradient.addColorStop(0.7, '#88CCFF');
                    crystalGradient.addColorStop(1, '#5599DD');
                    ctx.fillStyle = crystalGradient;
                    ctx.strokeStyle = '#3377AA';
                    ctx.lineWidth = 2;
                    break;
            }

            // Draw main ball
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, gameState.ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Add shine effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(gameState.ball.x - 2, gameState.ball.y - 2, gameState.ball.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Add dimples for golf ball texture
            if (gameState.selectedBall === 'classic') {
                ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const dimpleX = gameState.ball.x + Math.cos(angle) * 3;
                    const dimpleY = gameState.ball.y + Math.sin(angle) * 3;
                    ctx.beginPath();
                    ctx.arc(dimpleX, dimpleY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Add special effects based on ball type
            if (gameState.selectedBall === 'fire' && gameState.ballMoving) {
                // Fire trail effect
                for (let i = 0; i < 3; i++) {
                    const trailX = gameState.ball.x - gameState.ball.vx * (i + 1) * 0.5;
                    const trailY = gameState.ball.y - gameState.ball.vy * (i + 1) * 0.5;
                    const size = gameState.ball.radius * (1 - i * 0.2);

                    ctx.fillStyle = i === 0 ? 'rgba(255, 69, 0, 0.7)' :
                        i === 1 ? 'rgba(255, 140, 0, 0.5)' :
                            'rgba(255, 215, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (gameState.selectedBall === 'rainbow' && gameState.ballMoving) {
                // Rainbow trail effect
                const colors = ['rgba(255, 0, 0, 0.5)', 'rgba(255, 165, 0, 0.5)', 'rgba(255, 255, 0, 0.5)',
                    'rgba(0, 128, 0, 0.5)', 'rgba(0, 0, 255, 0.5)', 'rgba(75, 0, 130, 0.5)'];

                for (let i = 0; i < 6; i++) {
                    const trailX = gameState.ball.x - gameState.ball.vx * (i + 1) * 0.5;
                    const trailY = gameState.ball.y - gameState.ball.vy * (i + 1) * 0.5;
                    const size = gameState.ball.radius * (1 - i * 0.15);

                    ctx.fillStyle = colors[i];
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (gameState.selectedBall === 'crystal' && gameState.ballMoving) {
                // Crystal sparkle effect
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * gameState.ball.radius * 2;
                    const sparkleX = gameState.ball.x + Math.cos(angle) * distance;
                    const sparkleY = gameState.ball.y + Math.sin(angle) * distance;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 1 + Math.random(), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawHole() {
            // Draw hole shadow/depth
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(gameState.hole.x, gameState.hole.y, gameState.hole.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw hole inner shadow
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(gameState.hole.x, gameState.hole.y, gameState.hole.radius - 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw hole rim
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(gameState.hole.x, gameState.hole.y, gameState.hole.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Draw flag pole
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(gameState.hole.x + 25, gameState.hole.y - 50);
            ctx.lineTo(gameState.hole.x + 25, gameState.hole.y + 15);
            ctx.stroke();

            // Draw flag
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.moveTo(gameState.hole.x + 25, gameState.hole.y - 50);
            ctx.lineTo(gameState.hole.x + 50, gameState.hole.y - 35);
            ctx.lineTo(gameState.hole.x + 25, gameState.hole.y - 20);
            ctx.closePath();
            ctx.fill();

            // Flag border
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw flag number
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.currentLevel, gameState.hole.x + 37, gameState.hole.y - 32);

            // Draw hole indicator circle around hole
            ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(gameState.hole.x, gameState.hole.y, gameState.hole.radius + 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // If ball is in hole, draw it partially submerged
            if (gameState.ballInHole) {
                // Only show part of the ball above the hole
                ctx.save();
                ctx.beginPath();
                ctx.arc(gameState.hole.x, gameState.hole.y, gameState.hole.radius - 2, 0, Math.PI * 2);
                ctx.clip();

                // Draw ball at hole position but slightly elevated
                const ballY = gameState.hole.y + gameState.ball.radius * 0.7;

                // Draw ball shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(gameState.hole.x, ballY + 2, gameState.ball.radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw ball
                ctx.fillStyle = gameState.selectedBall === 'classic' ? 'white' :
                    gameState.selectedBall === 'gold' ? '#FFD700' :
                        gameState.selectedBall === 'rainbow' ? '#ff0080' :
                            gameState.selectedBall === 'fire' ? '#FF4500' : '#88CCFF';
                ctx.beginPath();
                ctx.arc(gameState.hole.x, ballY, gameState.ball.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function drawAimLine() {
            if (!gameState.isAiming || gameState.ballMoving) return;

            const dx = gameState.aimEnd.x - gameState.aimStart.x;
            const dy = gameState.aimEnd.y - gameState.aimStart.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxPower = clubs[gameState.selectedClub].maxPower;
            const power = Math.min(distance / 3, maxPower);

            // Update power bar
            powerFillElement.style.width = `${(power / maxPower) * 100}%`;

            // Draw aim line
            ctx.strokeStyle = power > maxPower * 0.8 ? '#e74c3c' : power > maxPower * 0.5 ? '#f39c12' : '#27ae60';
            ctx.lineWidth = 4;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(gameState.ball.x, gameState.ball.y);
            ctx.lineTo(gameState.aimEnd.x, gameState.aimEnd.y);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw power indicator circle
            ctx.fillStyle = ctx.strokeStyle;
            ctx.beginPath();
            ctx.arc(gameState.aimEnd.x, gameState.aimEnd.y, 6, 0, Math.PI * 2);
            ctx.fill();

            // Draw trajectory preview dots if enabled
            if (gameState.showTrajectory) {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.7)';
                const angle = Math.atan2(dy, dx);
                const precision = clubs[gameState.selectedClub].precision;

                // Crystal ball improves precision
                const effectivePrecision = gameState.selectedBall === 'crystal' ?
                    precision + 0.15 : precision;

                for (let i = 1; i <= 8; i++) {
                    const dotX = gameState.ball.x - Math.cos(angle) * (power * i * 3);
                    const dotY = gameState.ball.y - Math.sin(angle) * (power * i * 3);

                    // Add some randomness based on club precision
                    const randomAngle = angle + (Math.random() - 0.5) * (1 - effectivePrecision) * 0.3;
                    const randomX = gameState.ball.x - Math.cos(randomAngle) * (power * i * 3);
                    const randomY = gameState.ball.y - Math.sin(randomAngle) * (power * i * 3);

                    if (randomX >= 0 && randomX <= canvas.width && randomY >= 0 && randomY <= canvas.height) {
                        ctx.beginPath();
                        ctx.arc(randomX, randomY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw power text
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Power: ${Math.round((power / maxPower) * 100)}%`, gameState.aimEnd.x, gameState.aimEnd.y - 15);

            // Draw club info
            ctx.fillStyle = '#2c3e50';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${clubs[gameState.selectedClub].name}`, gameState.ball.x, gameState.ball.y - 20);
        }

        // Collision detection functions
        function checkCollision(ball, obstacle) {
            switch (obstacle.type) {
                case 'log':
                case 'wall':
                    // Handle rotated obstacles
                    if (obstacle.rotation) {
                        // Convert to radians
                        const angleRad = obstacle.rotation * Math.PI / 180;

                        // Translate point to origin
                        const centerX = obstacle.x + obstacle.width / 2;
                        const centerY = obstacle.y + obstacle.height / 2;

                        // Translate ball position
                        const translatedX = ball.x - centerX;
                        const translatedY = ball.y - centerY;

                        // Rotate coordinates
                        const rotatedX = translatedX * Math.cos(-angleRad) - translatedY * Math.sin(-angleRad);
                        const rotatedY = translatedX * Math.sin(-angleRad) + translatedY * Math.cos(-angleRad);

                        // Check against non-rotated rectangle
                        const halfWidth = obstacle.width / 2;
                        const halfHeight = obstacle.height / 2;

                        // Check if rotated point is inside the rectangle
                        if (Math.abs(rotatedX) <= halfWidth + ball.radius &&
                            Math.abs(rotatedY) <= halfHeight + ball.radius) {
                            return true;
                        }
                        return false;
                    } else {
                        // Regular rectangle collision
                        return ball.x + ball.radius > obstacle.x &&
                            ball.x - ball.radius < obstacle.x + obstacle.width &&
                            ball.y + ball.radius > obstacle.y &&
                            ball.y - ball.radius < obstacle.y + obstacle.height;
                    }

                case 'stone':
                case 'boulder':
                    const dx = ball.x - obstacle.x;
                    const dy = ball.y - obstacle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < ball.radius + obstacle.radius;

                case 'water':
                    if (obstacle.radius) {
                        // Circular water hazard
                        const dx = ball.x - obstacle.x;
                        const dy = ball.y - obstacle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance < obstacle.radius;
                    } else {
                        // Rectangular water hazard
                        return ball.x > obstacle.x - obstacle.width / 2 &&
                            ball.x < obstacle.x + obstacle.width / 2 &&
                            ball.y > obstacle.y - obstacle.height / 2 &&
                            ball.y < obstacle.y + obstacle.height / 2;
                    }

                case 'sand':
                    if (obstacle.radius) {
                        // Circular sand trap
                        const dx = ball.x - obstacle.x;
                        const dy = ball.y - obstacle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance < obstacle.radius;
                    } else {
                        // Rectangular sand trap
                        return ball.x > obstacle.x - obstacle.width / 2 &&
                            ball.x < obstacle.x + obstacle.width / 2 &&
                            ball.y > obstacle.y - obstacle.height / 2 &&
                            ball.y < obstacle.y + obstacle.height / 2;
                    }

                default:
                    return false;
            }
        }

        function handleCollision(ball, obstacle) {
            switch (obstacle.type) {
                case 'log':
                case 'wall':
                    if (obstacle.rotation) {
                        // Handle rotated obstacles
                        const angleRad = obstacle.rotation * Math.PI / 180;

                        // Get obstacle center
                        const centerX = obstacle.x + obstacle.width / 2;
                        const centerY = obstacle.y + obstacle.height / 2;

                        // Translate ball position
                        const translatedX = ball.x - centerX;
                        const translatedY = ball.y - centerY;

                        // Rotate coordinates
                        const rotatedX = translatedX * Math.cos(-angleRad) - translatedY * Math.sin(-angleRad);
                        const rotatedY = translatedX * Math.sin(-angleRad) + translatedY * Math.cos(-angleRad);

                        // Get closest point on rectangle
                        const halfWidth = obstacle.width / 2;
                        const halfHeight = obstacle.height / 2;

                        // Clamp rotated point to rectangle
                        const closestX = Math.max(-halfWidth, Math.min(halfWidth, rotatedX));
                        const closestY = Math.max(-halfHeight, Math.min(halfHeight, rotatedY));

                        // Calculate normal vector in rotated space
                        let normalX = rotatedX - closestX;
                        let normalY = rotatedY - closestY;

                        // Normalize
                        const length = Math.sqrt(normalX * normalX + normalY * normalY);
                        if (length > 0) {
                            normalX /= length;
                            normalY /= length;
                        }

                        // Rotate normal back
                        const worldNormalX = normalX * Math.cos(angleRad) - normalY * Math.sin(angleRad);
                        const worldNormalY = normalX * Math.sin(angleRad) + normalY * Math.cos(angleRad);

                        // Calculate reflection
                        const dotProduct = ball.vx * worldNormalX + ball.vy * worldNormalY;
                        ball.vx -= 2 * dotProduct * worldNormalX * 0.7;
                        ball.vy -= 2 * dotProduct * worldNormalY * 0.7;

                        // Move ball outside obstacle
                        const overlap = ball.radius - length;
                        if (overlap > 0) {
                            ball.x += worldNormalX * overlap;
                            ball.y += worldNormalY * overlap;
                        }
                    } else {
                        // Regular rectangle collision
                        const centerX = obstacle.x + obstacle.width / 2;
                        const centerY = obstacle.y + obstacle.height / 2;

                        const deltaX = ball.x - centerX;
                        const deltaY = ball.y - centerY;

                        if (Math.abs(deltaX / obstacle.width) > Math.abs(deltaY / obstacle.height)) {
                            ball.vx *= -0.7;
                            ball.x = deltaX > 0 ? obstacle.x + obstacle.width + ball.radius : obstacle.x - ball.radius;
                        } else {
                            ball.vy *= -0.7;
                            ball.y = deltaY > 0 ? obstacle.y + obstacle.height + ball.radius : obstacle.y - ball.radius;
                        }
                    }
                    break;

                case 'stone':
                case 'boulder':
                    const dx = ball.x - obstacle.x;
                    const dy = ball.y - obstacle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        const normalX = dx / distance;
                        const normalY = dy / distance;

                        const dotProduct = ball.vx * normalX + ball.vy * normalY;

                        // Rainbow ball is less affected by obstacles
                        const bounceFactor = gameState.selectedBall === 'rainbow' ? 0.9 : 0.8;

                        ball.vx -= 2 * dotProduct * normalX * bounceFactor;
                        ball.vy -= 2 * dotProduct * normalY * bounceFactor;

                        const overlap = ball.radius + obstacle.radius - distance;
                        ball.x += normalX * overlap;
                        ball.y += normalY * overlap;
                    }
                    break;

                case 'water':
                    // Water hazard penalty
                    showNotification('üí¶ Water Hazard!', `+${WATER_PENALTY} stroke penalty`);

                    // Reset ball position to previous shot
                    const level = levels[gameState.currentLevel - 1];
                    ball.x = level.ball.x;
                    ball.y = level.ball.y;
                    ball.vx = 0;
                    ball.vy = 0;

                    // Add penalty strokes
                    gameState.strokes += WATER_PENALTY;
                    updateDisplay();
                    break;

                case 'sand':
                    // Sand trap slows the ball significantly
                    ball.vx *= SAND_FRICTION;
                    ball.vy *= SAND_FRICTION;

                    // Show sand splash effect
                    for (let i = 0; i < 8; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 2 + 1;
                        const sandX = ball.x + Math.cos(angle) * ball.radius;
                        const sandY = ball.y + Math.sin(angle) * ball.radius;

                        // Create sand particle
                        const particle = document.createElement('div');
                        particle.style.position = 'absolute';
                        particle.style.width = '3px';
                        particle.style.height = '3px';
                        particle.style.backgroundColor = '#f9ca24';
                        particle.style.borderRadius = '50%';
                        particle.style.left = `${sandX}px`;
                        particle.style.top = `${sandY}px`;
                        particle.style.zIndex = '1000';
                        document.body.appendChild(particle);

                        // Animate and remove
                        setTimeout(() => {
                            particle.remove();
                        }, 500);
                    }

                    // Wedge club is better in sand
                    if (gameState.selectedClub === 'wedge') {
                        ball.vx *= 1.2;
                        ball.vy *= 1.2;
                    }
                    break;
            }
        }

        // Game update functions
        function updateBall() {
            if (gameState.ballInHole) return;

            if (Math.abs(gameState.ball.vx) < MIN_VELOCITY && Math.abs(gameState.ball.vy) < MIN_VELOCITY) {
                gameState.ball.vx = 0;
                gameState.ball.vy = 0;
                gameState.ballMoving = false;
                return;
            }

            gameState.ballMoving = true;

            // Apply friction
            const frictionFactor = gameState.selectedBall === 'fire' ? 0.99 : FRICTION;
            gameState.ball.vx *= frictionFactor;
            gameState.ball.vy *= frictionFactor;

            // Update position
            gameState.ball.x += gameState.ball.vx;
            gameState.ball.y += gameState.ball.vy;

            // Boundary collision
            if (gameState.ball.x - gameState.ball.radius <= 0) {
                gameState.ball.x = gameState.ball.radius;
                gameState.ball.vx *= -0.8;
            }
            if (gameState.ball.x + gameState.ball.radius >= canvas.width) {
                gameState.ball.x = canvas.width - gameState.ball.radius;
                gameState.ball.vx *= -0.8;
            }
            if (gameState.ball.y - gameState.ball.radius <= 0) {
                gameState.ball.y = gameState.ball.radius;
                gameState.ball.vy *= -0.8;
            }
            if (gameState.ball.y + gameState.ball.radius >= canvas.height) {
                gameState.ball.y = canvas.height - gameState.ball.radius;
                gameState.ball.vy *= -0.8;
            }

            // Obstacle collision
            gameState.obstacles.forEach(obstacle => {
                if (checkCollision(gameState.ball, obstacle)) {
                    handleCollision(gameState.ball, obstacle);
                }
            });

            // Check if ball reached hole
            const dx = gameState.ball.x - gameState.hole.x;
            const dy = gameState.ball.y - gameState.hole.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < gameState.hole.radius - 3 && !gameState.gameWon) {
                gameState.gameWon = true;
                gameState.ballInHole = true;

                // Ball falling animation
                const ballFallAnimation = () => {
                    gameState.ball.vx *= 0.8;
                    gameState.ball.vy *= 0.8;

                    gameState.ball.x = gameState.ball.x * 0.8 + gameState.hole.x * 0.2;
                    gameState.ball.y = gameState.ball.y * 0.8 + gameState.hole.y * 0.2;

                    if (Math.abs(gameState.ball.x - gameState.hole.x) > 0.5 ||
                        Math.abs(gameState.ball.y - gameState.hole.y) > 0.5) {
                        requestAnimationFrame(ballFallAnimation);
                    } else {
                        finishHole();
                    }
                };

                ballFallAnimation();
            }
        }

        function finishHole() {
            const coinsEarned = awardCoins(gameState.strokes);

            // Update best score
            if (!gameState.bestScores[gameState.currentLevel] ||
                gameState.strokes < gameState.bestScores[gameState.currentLevel]) {
                gameState.bestScores[gameState.currentLevel] = gameState.strokes;
                saveGameData();
                updateDisplay();
            }

            // Unlock next level if this is the highest level completed
            if (gameState.currentLevel === gameState.maxUnlockedLevel &&
                gameState.currentLevel < levels.length) {
                gameState.maxUnlockedLevel++;
                saveGameData();

                setTimeout(() => {
                    showNotification('üéñÔ∏è Level Unlocked!', `Level ${gameState.maxUnlockedLevel} is now available!`);
                }, 2000);
            }

            // Celebrate animation on UI elements
            document.querySelector('h1').classList.add('celebrate');
            setTimeout(() => {
                document.querySelector('h1').classList.remove('celebrate');
            }, 500);

            // Show completion message
            setTimeout(() => {
                const level = levels[gameState.currentLevel - 1];
                const par = level.par;
                let performanceText = '';

                if (gameState.strokes === 1) {
                    performanceText = "HOLE IN ONE! üéØ";
                } else if (gameState.strokes <= par - 2) {
                    performanceText = "EAGLE! ü¶Ö";
                } else if (gameState.strokes === par - 1) {
                    performanceText = "BIRDIE! üê¶";
                } else if (gameState.strokes === par) {
                    performanceText = "PAR üëç";
                } else if (gameState.strokes === par + 1) {
                    performanceText = "BOGEY üòê";
                } else if (gameState.strokes === par + 2) {
                    performanceText = "DOUBLE BOGEY üòï";
                } else {
                    performanceText = "KEEP PRACTICING üèåÔ∏è";
                }

                const message = `üéâ Level ${gameState.currentLevel} Complete!\n\n` +
                    `${performanceText}\n` +
                    `‚õ≥ Strokes: ${gameState.strokes} (Par: ${par})\n` +
                    `üí∞ Coins earned: ${coinsEarned}\n\n` +
                    `Great job! Ready for the next challenge?`;
                alert(message);
            }, 1000);
        }

        // Rendering functions
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grass background
            drawGrassBackground();

            // Draw decorations that should appear behind obstacles
            gameState.decorations.forEach(decoration => {
                drawDecoration(decoration);
            });

            // Draw obstacles
            gameState.obstacles.forEach(obstacle => {
                drawObstacle(obstacle);
            });

            // Draw hole
            drawHole();

            // Draw ball
            drawBall();

            // Draw aim line
            drawAimLine();
        }

        function gameLoop() {
            updateBall();
            render();
            requestAnimationFrame(gameLoop);
        }

        // UI update functions
        function updateDisplay() {
            strokesElement.textContent = gameState.strokes;
            bestScoreElement.textContent = gameState.bestScores[gameState.currentLevel] || '--';
            currentLevelElement.textContent = gameState.currentLevel;
            updateCoinsDisplay();
        }

        // Game control functions
        function resetGame() {
            loadLevel(gameState.currentLevel - 1);
            powerFillElement.style.width = '0%';
            showNotification('üîÑ Level Reset', 'Starting over with 0 strokes');
        }

        function nextLevel() {
            if (gameState.gameWon) {
                if (gameState.currentLevel < levels.length) {
                    gameState.currentLevel++;
                    loadLevel(gameState.currentLevel - 1);
                    powerFillElement.style.width = '0%';
                } else {
                    showNotification('üèÜ Game Complete!', 'You finished all available levels!');
                }
            } else {
                showNotification('‚õ≥ Level Incomplete', 'Complete the current level first!');
            }
        }

        // Event listeners setup
        function setupEventListeners() {
            // Button event listeners
            document.getElementById('resetBtn').addEventListener('click', resetGame);
            document.getElementById('nextBtn').addEventListener('click', nextLevel);
            document.getElementById('shopBtn').addEventListener('click', openShop);
            document.getElementById('closeShopBtn').addEventListener('click', closeShop);
            document.getElementById('levelSelectBtn').addEventListener('click', openLevelModal);
            document.getElementById('closeLevelBtn').addEventListener('click', closeLevelModal);

            // Equipment selection
            document.querySelectorAll('[data-club]').forEach(option => {
                option.addEventListener('click', (e) => {
                    const clubType = e.target.getAttribute('data-club');
                    selectClub(clubType);
                });
            });

            document.querySelectorAll('[data-ball]').forEach(option => {
                option.addEventListener('click', (e) => {
                    const ballType = e.target.getAttribute('data-ball');
                    selectBall(ballType);
                });
            });

            // Shop buy buttons
            document.querySelectorAll('.buy-btn[data-item]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const item = e.target.getAttribute('data-item');
                    const price = parseInt(e.target.getAttribute('data-price'));
                    buyItem(item, price);
                });
            });

            // Canvas mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);

            // Touch events
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);

            // Close modals when clicking outside
            document.getElementById('shopModal').addEventListener('click', (e) => {
                if (e.target.id === 'shopModal') {
                    closeShop();
                }
            });

            document.getElementById('levelModal').addEventListener('click', (e) => {
                if (e.target.id === 'levelModal') {
                    closeLevelModal();
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'r') {
                    resetGame();
                } else if (e.key === 'n' && gameState.gameWon) {
                    nextLevel();
                } else if (e.key === 's') {
                    openShop();
                } else if (e.key === 'l') {
                    openLevelModal();
                } else if (e.key === 'Escape') {
                    closeShop();
                    closeLevelModal();
                }
            });
        }

        // Mouse and touch event handlers
        function handleMouseDown(e) {
            if (gameState.ballMoving || gameState.ballInHole) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            const dx = x - gameState.ball.x;
            const dy = y - gameState.ball.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= gameState.ball.radius + 30) {
                gameState.isAiming = true;
                gameState.aimStart = { x: gameState.ball.x, y: gameState.ball.y };
                gameState.aimEnd = { x, y };
            }
        }

        function handleMouseMove(e) {
            if (!gameState.isAiming) return;

            const rect = canvas.getBoundingClientRect();
            gameState.aimEnd = {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function handleMouseUp() {
            if (!gameState.isAiming) return;

            shootBall();
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            handleMouseDown(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            handleMouseMove(mouseEvent);
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            handleMouseUp();
        }

        function shootBall() {
            const dx = gameState.aimStart.x - gameState.aimEnd.x;
            const dy = gameState.aimStart.y - gameState.aimEnd.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 5) {
                const club = clubs[gameState.selectedClub];
                const power = Math.min(distance / 3, club.maxPower);

                // Crystal ball improves precision
                const precision = gameState.selectedBall === 'crystal' ?
                    club.precision + 0.15 : club.precision;

                const angle = Math.atan2(dy, dx);
                const randomAngle = angle + (Math.random() - 0.5) * (1 - precision) * 0.3;

                gameState.ball.vx = Math.cos(randomAngle) * power * 0.4;
                gameState.ball.vy = Math.sin(randomAngle) * power * 0.4;

                // Fire ball moves faster
                if (gameState.selectedBall === 'fire') {
                    gameState.ball.vx *= 1.1;
                    gameState.ball.vy *= 1.1;
                }

                gameState.strokes++;
                updateDisplay();

                // Play swing animation
                const swingElement = document.createElement('div');
                swingElement.textContent = 'üèåÔ∏è';
                swingElement.style.position = 'absolute';
                swingElement.style.fontSize = '24px';
                swingElement.style.left = `${gameState.ball.x + 20}px`;
                swingElement.style.top = `${gameState.ball.y - 20}px`;
                swingElement.style.animation = 'swing 0.5s forwards';
                document.body.appendChild(swingElement);

                setTimeout(() => {
                    swingElement.remove();
                }, 500);

                // Add swing animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes swing {
                        0% { transform: rotate(0deg); }
                        50% { transform: rotate(-45deg); }
                        100% { transform: rotate(0deg); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }

            gameState.isAiming = false;
            powerFillElement.style.width = '0%';
        }

        // Initialize game
        function initGame() {
            console.log('Initzing Mini Golf Championship...');
            updateDisplay();
            updateEquipmentDisplay();
            updateShopDisplay();
            loadLevel(gameState.currentLevel - 1);
            setupEventListeners();
            gameLoop();
            console.log('Game initialized successfully!');

            // Welcome message
            setTimeout(() => {
                showNotification('üèåÔ∏è Welcome to Mini Golf Championship!', 'Click and drag from the ball to aim and shoot!');
            }, 1000);
        }

        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>

</html>